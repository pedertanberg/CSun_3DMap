import{s as F,lb as V,lq as g,i8 as X,lr as Y,ls as Z,a6 as tt,bO as et,bQ as nt,bR as st,lt as at,lu as it,lv as G,cO as j}from"./index.347f2ee6.js";var x;(function(t){t[t.Auto=0]="Auto",t[t.Euclidean=1]="Euclidean",t[t.Geodesic=2]="Geodesic"})(x||(x={}));function O(t){if(!t)return null;if(X(t)&&t.wkid){const e=Y[t.wkid];if(e)return e}if(t.wkt){const e=rt(t.wkt);if(e)return e}return null}function rt(t){const e=Z.exec(t);if(!e||e.length!==2)return null;const n=e[1].split(",");if(!n||n.length<3)return null;const s=parseFloat(n[1]),a=parseFloat(n[2]);return isNaN(s)||isNaN(a)?null:{a:s,f:a===0?0:1/a}}function ot(t){const e=O(t!=null?t:tt.WGS84);if(ct(e))return e;const n=e.a*(1-e.f);return Object.assign(e,{b:n,eSq:1-(n/e.a)**2,radius:(2*e.a+n)/3,densificationRatio:1e4/((2*e.a+n)/3)})}function ct(t){return t!=null&&"b"in t&&"eSq"in t&&"radius"in t}function ht(t){return O(t)!==null}function dt(t,e="meters"){if(!t)throw new F("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(t.some(s=>!ht(s.spatialReference)))throw new F("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let s=0;s<t.length;s++){const a=t[s],{spatialReference:m}=a,v=a.type==="polyline"?a.paths:a.rings;let r=0;for(let R=0;R<v.length;R++){const o=v[R];let f=0;for(let M=1;M<o.length;M++){const z=o[M-1][0],b=o[M][0],w=o[M-1][1],h=o[M][1];if(w!==h||z!==b){const c=new lt;ut(c,[z,w],[b,h],m),f+=c.distance}}r+=f}r=V(r,"meters",e),n.push(r)}return n}class lt{constructor(e=0,n,s){this.distance=e,this.azimuth=n,this.reverseAzimuth=s}}function ut(t,e,n,s){const a=e[0]*g,m=e[1]*g,v=n[0]*g,r=n[1]*g,{a:R,b:o,f,radius:M}=ot(s),z=v-a,b=Math.atan((1-f)*Math.tan(m)),w=Math.atan((1-f)*Math.tan(r)),h=Math.sin(b),c=Math.cos(b),_=Math.sin(w),l=Math.cos(w);let S,$,p,i,A,E,N,P,U,q,y=1e3,u=z;do{if(N=Math.sin(u),P=Math.cos(u),p=Math.sqrt(l*N*(l*N)+(c*_-h*l*P)*(c*_-h*l*P)),p===0)return t.distance=0,t.azimuth=void 0,t.reverseAzimuth=void 0,t;A=h*_+c*l*P,E=Math.atan2(p,A),U=c*l*N/p,$=1-U*U,i=A-2*h*_/$,isNaN(i)&&(i=0),q=f/16*$*(4+f*(4-3*$)),S=u,u=z+(1-q)*f*U*(E+q*p*(i+q*A*(2*i*i-1)))}while(Math.abs(u-S)>1e-12&&--y>0);if(y===0){const B=M,H=Math.acos(Math.sin(m)*Math.sin(r)+Math.cos(m)*Math.cos(r)*Math.cos(v-a))*B,D=v-a,J=Math.sin(D)*Math.cos(r),K=Math.cos(m)*Math.sin(r)-Math.sin(m)*Math.cos(r)*Math.cos(D),L=Math.atan2(J,K);return t.azimuth=L/g,t.distance=H,t.reverseAzimuth=void 0,t}const d=$*(R*R-o*o)/(o*o),k=d/1024*(256+d*(d*(74-47*d)-128)),I=o*(1+d/16384*(4096+d*(d*(320-175*d)-768)))*(E-k*p*(i+k/4*(A*(2*i*i-1)-k/6*i*(4*p*p-3)*(4*i*i-3)))),Q=Math.atan2(l*Math.sin(u),c*_-h*l*Math.cos(u)),W=Math.atan2(c*Math.sin(u),c*_*Math.cos(u)-h*l);return t.azimuth=Q/g,t.distance=I,t.reverseAzimuth=W/g,t}function mt(t,e){if(et(e,0,0,0),t.length>0){for(let n=0;n<t.length;++n)nt(e,e,t[n]);st(e,e,1/t.length)}}function gt(t,e,n,s){s.projectToRenderScreen(t,T),s.projectToRenderScreen(e,C),at(n,Mt,ft),it(n,n)}const T=G(),ft=T,C=G(),Mt=C;class vt{constructor(e=null){this.spatialReference=e}get spatialReference(){return this._spatialReference}set spatialReference(e){e!==this._spatialReference&&(this._spatialReference=e,this._updateNormalizationFactors())}normalizeDistance(e){return e*this._metersPerDistanceUnit}normalizeElevation(e){return e*this._metersPerElevationUnit}normalizeArea(e){return e*this._squareMetersPerAreaUnit}_updateNormalizationFactors(){this._metersPerDistanceUnit=j(this._spatialReference,1),this._metersPerElevationUnit=j(this._spatialReference,1),this._squareMetersPerAreaUnit=this._metersPerDistanceUnit*this._metersPerDistanceUnit}}export{ht as M,ut as b,mt as c,x as e,gt as f,vt as t,lt as v,dt as y};
