import{hq as Me,hr as Ne,aZ as q,gu as ye,fn as K,hs as xe,r as G,bY as Ce,hg as Y,ht as ne,s as A,t as P,eg as qe,a6 as W,hu as Ge,hv as H,hw as Pe,hx as J,v as Oe,hl as Ze,hd as _e,hb as je,hy as Be,b2 as Le,fi as Qe,hz as Ue,hA as re,br as Fe,hB as X,hC as Ye,hD as He,hE as Je,hF as Xe,hG as ke,hH as oe,hI as le,hJ as Ke,hK as We,hL as et,b6 as tt}from"./index.f2e9cdcf.js";import{WhereClause as it}from"./WhereClause.7bb0c466.js";import{c as B,x as st,m as at,f as ue,d as ce,V as nt,T as rt,F as ot,D as lt,N as ut,S as ct,v as ht,p as dt}from"./utils.2fc37d0a.js";import{t as Ie}from"./json.879c9adc.js";const L=[0,0];function Ve(s,t){if(!t)return null;if("x"in t){const e={x:0,y:0};return[e.x,e.y]=s(t.x,t.y,L),t.z!=null&&(e.z=t.z),t.m!=null&&(e.m=t.m),e}if("xmin"in t){const e={xmin:0,ymin:0,xmax:0,ymax:0};return[e.xmin,e.ymin]=s(t.xmin,t.ymin,L),[e.xmax,e.ymax]=s(t.xmax,t.ymax,L),t.hasZ&&(e.zmin=t.zmin,e.zmax=t.zmax,e.hasZ=!0),t.hasM&&(e.mmin=t.mmin,e.mmax=t.mmax,e.hasM=!0),e}return"rings"in t?{rings:he(t.rings,s),hasM:t.hasM,hasZ:t.hasZ}:"paths"in t?{paths:he(t.paths,s),hasM:t.hasM,hasZ:t.hasZ}:"points"in t?{points:Se(t.points,s),hasM:t.hasM,hasZ:t.hasZ}:null}function he(s,t){const e=[];for(const i of s)e.push(Se(i,t));return e}function Se(s,t){const e=[];for(const i of s){const a=t(i[0],i[1],[0,0]);e.push(a),i.length>2&&a.push(i[2]),i.length>3&&a.push(i[3])}return e}async function Te(s,t){if(!s||!t)return;const e=Array.isArray(s)?s.map(i=>G(i.geometry)?i.geometry.spatialReference:null).filter(G):[s];await Ce(e.map(i=>({source:i,dest:t})))}const ve=Ve.bind(null,Me),we=Ve.bind(null,Ne);function Z(s,t,e,i){if(!s||(e||(e=t,t=s.spatialReference),!Y(t)||!Y(e)||q(t,e)))return s;if(ye(t,e)){const a=K(e)?ve(s):we(s);return a.spatialReference=e,a}return xe(Ie,[s],t,e,null,i)[0]}class ft{constructor(){this._jobs=[],this._timer=null,this._process=this._process.bind(this)}async push(t,e,i){if(!t||!t.length||!e||!i||q(e,i))return t;const a={geometries:t,inSpatialReference:e,outSpatialReference:i,resolve:null};return this._jobs.push(a),new Promise(n=>{a.resolve=n,this._timer===null&&(this._timer=setTimeout(this._process,10))})}_process(){this._timer=null;const t=this._jobs.shift();if(!t)return;const{geometries:e,inSpatialReference:i,outSpatialReference:a,resolve:n}=t;ye(i,a)?K(a)?n(e.map(ve)):n(e.map(we)):n(xe(Ie,e,i,a,null,null)),this._jobs.length>0&&(this._timer=setTimeout(this._process,10))}}const mt=new ft;function At(s,t,e){return mt.push(s,t,e)}class gt{constructor(t,e){this._cache=new ne(t),this._invalidCache=new ne(e)}get(t,e){const i=`${e.uid}:${t}`,a=this._cache.get(i);if(a)return a;if(this._invalidCache.get(i)!==void 0)return null;try{const n=it.create(t,e);return this._cache.put(i,n),n}catch{return this._invalidCache.put(i,null),null}}}const ee=new gt(50,500),D="feature-store:unsupported-query",be=" as ",pt=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function Dt(s,t){if(!t)return!0;const e=ee.get(t,s);if(!e)throw new A(D,"invalid SQL expression",{where:t});if(!e.isStandardized)throw new A(D,"where clause is not standard",{where:t});return te(s,e.fieldNames,"where clause contains missing fields"),!0}function $t(s,t,e){if(!t)return!0;const i=ee.get(t,s);if(!i)throw new A(D,"invalid SQL expression",{having:t});if(!i.isAggregate)throw new A(D,"having does not contain a valid aggregate function",{having:t});const a=i.fieldNames;if(te(s,a,"having contains missing fields"),!i.getExpressions().every(n=>{const{aggregateType:r,field:o}=n,l=s.has(o)&&s.get(o).name;return e.some(c=>{const{onStatisticField:u,statisticType:h}=c;return(s.has(u)&&s.get(u).name)===l&&h.toLowerCase().trim()===r})}))throw new A(D,"expressions in having should also exist in outStatistics",{having:t});return!0}function C(s,t){return s?ee.get(s,t):null}function te(s,t,e,i=!0){const a=[];for(const n of t)if(n!=="*"&&!s.has(n))if(i){const r=ze(n);try{const o=C(r,s);if(!o)throw new A(D,"invalid SQL expression",{where:r});if(!o.isStandardized)throw new A(D,"expression is not standard",{clause:o});te(s,o.fieldNames,"expression contains missing fields")}catch(o){const l=o&&o.details;if(l&&(l.clause||l.where))throw o;l&&l.missingFields?a.push(...l.missingFields):a.push(n)}}else a.push(n);if(a.length)throw new A(D,e,{missingFields:a})}function ze(s){return s.split(be)[0]}function yt(s){return s.split(be)[1]}function Et(s,t){const e=t.get(s);return!!e&&!pt.has(e.type)}class O{constructor(t,e,i){var n;this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=(n=t.returnDistinctValues)!=null?n:!1,this.fieldsIndex=i,this.featureAdapter=e;const a=t.outFields;if(a&&!a.includes("*")){this.outFields=a;let r=0;for(const o of a){const l=ze(o),c=this.fieldsIndex.get(l),u=c?null:C(l,i),h=c?c.name:yt(o)||"FIELD_EXP_"+r++;this._fieldDataCache.set(o,{alias:h,clause:u})}}}countDistinctValues(t){return this.returnDistinctValues?(t.forEach(e=>this.getAttributes(e)),this._returnDistinctMap.size):t.length}getAttributes(t){const e=this._processAttributesForOutFields(t);return this._processAttributesForDistinctValues(e)}getFieldValue(t,e,i){const a=i?i.name:e;let n=null;return this._fieldDataCache.has(a)?n=this._fieldDataCache.get(a).clause:i||(n=C(e,this.fieldsIndex),this._fieldDataCache.set(a,{alias:a,clause:n})),i?this.featureAdapter.getAttribute(t,a):n.calculateValue(t,this.featureAdapter)}getDataValue(t,e){const i=e.normalizationType,a=e.normalizationTotal;let n=this.getFieldValue(t,e.field,this.fieldsIndex.get(e.field));if(e.field2&&(n=`${B(n)}${e.fieldDelimiter}${B(this.getFieldValue(t,e.field2,this.fieldsIndex.get(e.field2)))}`,e.field3&&(n=`${n}${e.fieldDelimiter}${B(this.getFieldValue(t,e.field3,this.fieldsIndex.get(e.field3)))}`)),i&&Number.isFinite(n)){const r=i==="field"&&e.normalizationField?this.getFieldValue(t,e.normalizationField,this.fieldsIndex.get(e.normalizationField)):null;n=st(n,i,r,a)}return n}getExpressionValue(t,e,i,a){const n={attributes:this.featureAdapter.getAttributes(t),layer:{fields:this.fieldsIndex.fields}},r=a.createExecContext(n,i);return a.executeFunction(e,r)}getExpressionValues(t,e,i,a){const n={fields:this.fieldsIndex.fields};return t.map(r=>{const o={attributes:this.featureAdapter.getAttributes(r),layer:n},l=a.createExecContext(o,i);return a.executeFunction(e,l)})}validateItem(t,e){return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:C(e,this.fieldsIndex)}),this._fieldDataCache.get(e).clause.testFeature(t,this.featureAdapter)}validateItems(t,e){return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:C(e,this.fieldsIndex)}),this._fieldDataCache.get(e).clause.testSet(t,this.featureAdapter)}_processAttributesForOutFields(t){const e=this.outFields;if(!e||!e.length)return this.featureAdapter.getAttributes(t);const i={};for(const a of e){const{alias:n,clause:r}=this._fieldDataCache.get(a);i[n]=r?r.calculateValue(t,this.featureAdapter):this.featureAdapter.getAttribute(t,n)}return i}_processAttributesForDistinctValues(t){if(P(t)||!this.returnDistinctValues)return t;const e=this.outFields,i=[];if(e)for(const r of e){const{alias:o}=this._fieldDataCache.get(r);i.push(t[o])}else for(const r in t)i.push(t[r]);const a=`${(e||["*"]).join(",")}=${i.join(",")}`;let n=this._returnDistinctMap.get(a)||0;return this._returnDistinctMap.set(a,++n),n>1?null:t}}const xt=new qe({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),de=Object.freeze({}),fe=new W,_t=new W,k=new W,b={esriGeometryPoint:X,esriGeometryPolyline:Ye,esriGeometryPolygon:He,esriGeometryMultipoint:Je};function me(s,t,e,i=s.hasZ,a=s.hasM){if(P(t))return null;const n=s.hasZ&&i,r=s.hasM&&a;if(e){const o=H(k,t,s.hasZ,s.hasM,"esriGeometryPoint",e,i,a);return X(o,n,r)}return X(t,n,r)}function Q(s,t,e,i,a,n,r=t,o=e){var h,f,d,m,x,_;const l=t&&r,c=e&&o,u=G(i)?"coords"in i?i:i.geometry:null;if(P(u))return null;if(a){let y=Ge(_t,u,t,e,s,a,r,o);return n&&(y=H(k,y,l,c,s,n)),(f=(h=b[s])==null?void 0:h.call(b,y,l,c))!=null?f:null}if(n){const y=H(k,u,t,e,s,n,r,o);return(m=(d=b[s])==null?void 0:d.call(b,y,l,c))!=null?m:null}return Pe(fe,u,t,e,r,o),(_=(x=b[s])==null?void 0:x.call(b,fe,l,c))!=null?_:null}async function Mt(s,t,e){const{outFields:i,orderByFields:a,groupByFieldsForStatistics:n,outStatistics:r}=s;if(i)for(let o=0;o<i.length;o++)i[o]=i[o].trim();if(a)for(let o=0;o<a.length;o++)a[o]=a[o].trim();if(n)for(let o=0;o<n.length;o++)n[o]=n[o].trim();if(r)for(let o=0;o<r.length;o++)r[o].onStatisticField&&(r[o].onStatisticField=r[o].onStatisticField.trim());return s.geometry&&!s.outSR&&(s.outSR=s.geometry.spatialReference),Ft(s,t,e)}async function Ft(s,t,e){var n;if(!s)return null;let{where:i}=s;if(s.where=i=i&&i.trim(),(!i||/^1 *= *1$/.test(i)||t&&t===i)&&(s.where=null),!s.geometry)return s;let a=await Vt(s);if(s.distance=0,s.units=null,s.spatialRel==="esriSpatialRelEnvelopeIntersects"){const{spatialReference:r}=s.geometry;a=J(a),a.spatialReference=r}if(a){await Te(a.spatialReference,e),a=It(a,e);const r=(await Oe(Ze(a)))[0];if(P(r))throw de;const o="quantizationParameters"in s&&((n=s.quantizationParameters)==null?void 0:n.tolerance)||"maxAllowableOffset"in s&&s.maxAllowableOffset||0,l=o&&Re(a,e)?{densificationStep:8*o}:void 0,c=r.toJSON(),u=await Z(c,c.spatialReference,e,l);if(!u)throw de;u.spatialReference=e,s.geometry=u}return s}function Re(s,t){if(!s)return!1;const e=s.spatialReference;return(_e(s)||je(s)||Be(s))&&!q(e,t)&&!Le(e,t)}function It(s,t){const e=s.spatialReference;return Re(s,t)&&_e(s)?{spatialReference:e,rings:[[[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]]]}:s}async function Vt(s){const{distance:t,units:e}=s,i=s.geometry;if(t==null||"vertexAttributes"in i)return i;const a=i.spatialReference,n=e?xt.fromJSON(e):Qe(a),r=a&&(Ue(a)||K(a))?i:await Te(a,re).then(()=>Z(i,re));return(await St())(r.spatialReference,r,t,n)}async function St(){return(await Fe(()=>import("./geometryEngineJSON.3d6e7890.js"),["assets/geometryEngineJSON.3d6e7890.js","assets/geometryEngineBase.82b25ca5.js","assets/geometryEngineJSON.f9e9a36f.js","assets/json.879c9adc.js"])).geodesicBuffer}function U(s){return s&&Ae in s?JSON.parse(JSON.stringify(s,Tt)):s}const Ae="_geVersion",Tt=(s,t)=>s!==Ae?t:void 0;class Nt{constructor(t,e,i){this.items=t,this.query=e,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const t=new O(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return t.countDistinctValues(this.items);const{groupByFieldsForStatistics:e,having:i,outStatistics:a}=this.query;if(!(e==null?void 0:e.length))return 1;const r=new Map,o=new Map,l=new Set;for(const c of a){const{statisticType:u}=c,h=u!=="exceedslimit"?c.onStatisticField:void 0;if(!o.has(h)){const d=[];for(const m of e){const x=this._getAttributeValues(t,m,r);d.push(x)}o.set(h,this._calculateUniqueValues(d,t.returnDistinctValues))}const f=o.get(h);for(const d in f){const{data:m,items:x}=f[d],_=m.join(",");i&&!t.validateItems(x,i)||l.add(_)}}return l.size}async createQueryResponse(){let t;return this.query.outStatistics?t=this.query.outStatistics.some(e=>e.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query):t=this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry&&(Y(this.query.outSR)&&!q(this.query.geometry.spatialReference,this.query.outSR)?t.queryGeometry=U({spatialReference:this.query.outSR,...Z(this.query.geometry,this.query.geometry.spatialReference,this.query.outSR)}):t.queryGeometry=U({spatialReference:this.query.outSR,...this.query.geometry})),t}createSnappingResponse(t,e){const i=this.featureAdapter,a=ge(this.hasZ,this.hasM),{point:n}=t,r=typeof t.distance=="number"?t.distance:t.distance.x,o=typeof t.distance=="number"?t.distance:t.distance.y,l={candidates:[]},c=this.geometryType==="esriGeometryPolygon",u=n.z!=null,h=n.m!=null,f=this._getPointCreator(n,u,h,this.spatialReference,e),d=new pe(null,0),m=new pe(null,0),x={x:0,y:0,z:0};for(const _ of this.items){const y=i.getGeometry(_);if(P(y))continue;const{coords:I,lengths:V}=y;if(d.coords=I,m.coords=I,t.types&j.EDGE){let F=0;for(let p=0;p<V.length;p++){const g=V[p];for(let S=0;S<g;S++,F+=a){const v=d;if(v.coordsIndex=F,S!==g-1){const z=m;z.coordsIndex=F+a;const T=x;vt(x,n,v,z);const w=(n.x-T.x)/r,E=(n.y-T.y)/o,$=w*w+E*E;$<=1&&l.candidates.push(Xe(i.getObjectId(_),f(T),Math.sqrt($),f(v),f(z)))}}}}if(t.types&j.VERTEX){const F=c?I.length-a:I.length;for(let p=0;p<F;p+=a){const g=d;g.coordsIndex=p;const S=(n.x-g.x)/r,v=(n.y-g.y)/o,z=S*S+v*v;z<=1&&l.candidates.push(ke(i.getObjectId(_),f(g),Math.sqrt(z)))}}}return l.candidates.sort((_,y)=>_.distance-y.distance),l}_getPointCreator(t,e,i,a,n){const r=G(n)&&!q(a,n)?u=>Z(u,a,n):u=>u,{hasZ:o}=this,l=0,c=t.m;return e&&i?o?({x:u,y:h,z:f})=>r({x:u,y:h,z:f,m:c}):({x:u,y:h})=>r({x:u,y:h,z:l,m:c}):e?o?({x:u,y:h,z:f})=>r({x:u,y:h,z:f}):({x:u,y:h})=>r({x:u,y:h,z:l}):i?({x:u,y:h})=>r({x:u,y:h,m:c}):({x:u,y:h})=>r({x:u,y:h})}async createSummaryStatisticsResponse(t){const{field:e,valueExpression:i,normalizationField:a,normalizationType:n,normalizationTotal:r,minValue:o,maxValue:l,scale:c}=t,u=this.fieldsIndex.isDateField(e),h=await this._getDataValues({field:e,valueExpression:i,normalizationField:a,normalizationType:n,normalizationTotal:r,scale:c}),f=at({normalizationType:n,normalizationField:a,minValue:o,maxValue:l}),d=this.fieldsIndex.get(e),m={value:.5,fieldType:d==null?void 0:d.type},x=oe(d)?ue({values:h,supportsNullCount:f,percentileParams:m}):ce({values:h,minValue:o,maxValue:l,useSampleStdDev:!n,supportsNullCount:f,percentileParams:m});return nt(x,u)}async createUniqueValuesResponse(t){const{field:e,valueExpression:i,domains:a,returnAllCodedValues:n,scale:r}=t,o=await this._getDataValues({field:e,field2:t.field2,field3:t.field3,fieldDelimiter:t.fieldDelimiter,valueExpression:i,scale:r}),l=rt(o);return ot(l,a,n,t.fieldDelimiter)}async createClassBreaksResponse(t){const{field:e,valueExpression:i,normalizationField:a,normalizationType:n,normalizationTotal:r,classificationMethod:o,standardDeviationInterval:l,minValue:c,maxValue:u,numClasses:h,scale:f}=t,d=await this._getDataValues({field:e,valueExpression:i,normalizationField:a,normalizationType:n,normalizationTotal:r,scale:f}),m=lt(d,{field:e,normalizationField:a,normalizationType:n,normalizationTotal:r,classificationMethod:o,standardDeviationInterval:l,minValue:c,maxValue:u,numClasses:h});return ut(m,o)}async createHistogramResponse(t){const{field:e,valueExpression:i,normalizationField:a,normalizationType:n,normalizationTotal:r,classificationMethod:o,standardDeviationInterval:l,minValue:c,maxValue:u,numBins:h,scale:f}=t,d=await this._getDataValues({field:e,valueExpression:i,normalizationField:a,normalizationType:n,normalizationTotal:r,scale:f});return ct(d,{field:e,normalizationField:a,normalizationType:n,normalizationTotal:r,classificationMethod:o,standardDeviationInterval:l,minValue:c,maxValue:u,numBins:h})}_sortFeatures(t,e,i){if(t.length>1&&e&&e.length)for(const a of e.reverse()){const n=a.split(" "),r=n[0],o=this.fieldsIndex.get(r),l=n[1]&&n[1].toLowerCase()==="desc",c=ht(o==null?void 0:o.type,l);t.sort((u,h)=>{const f=i(u,r,o),d=i(h,r,o);return c(f,d)})}}_createFeatureQueryResponse(t){const e=this.items,{geometryType:i,hasM:a,hasZ:n,objectIdField:r,spatialReference:o}=this,{outFields:l,outSR:c,quantizationParameters:u,resultRecordCount:h,resultOffset:f,returnZ:d,returnM:m}=t,x=h!=null&&e.length>(f||0)+h,_=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map(y=>this.fieldsIndex.get(y)));return{exceededTransferLimit:x,features:this._createFeatures(t,e),fields:_,geometryType:i,hasM:a&&m,hasZ:n&&d,objectIdFieldName:r,spatialReference:U(c||o),transform:u&&le(u)||null}}_createFeatures(t,e){const i=new O(t,this.featureAdapter,this.fieldsIndex),{hasM:a,hasZ:n}=this,{orderByFields:r,quantizationParameters:o,returnGeometry:l,returnCentroid:c,maxAllowableOffset:u,resultOffset:h,resultRecordCount:f,returnZ:d=!1,returnM:m=!1}=t,x=n&&d,_=a&&m;let y=[],I=0;const V=[...e];if(this._sortFeatures(V,r,(p,g,S)=>i.getFieldValue(p,g,S)),l||c){const p=le(o);if(l&&!c)for(const g of V)y[I++]={attributes:i.getAttributes(g),geometry:Q(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(g),u,p,x,_)};else if(!l&&c)for(const g of V)y[I++]={attributes:i.getAttributes(g),centroid:me(this,this.featureAdapter.getCentroid(g,this),p)};else for(const g of V)y[I++]={attributes:i.getAttributes(g),centroid:me(this,this.featureAdapter.getCentroid(g,this),p),geometry:Q(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(g),u,p,x,_)}}else for(const p of V){const g=i.getAttributes(p);g&&(y[I++]={attributes:g})}const F=h||0;if(f!=null){const p=F+f;y=y.slice(F,Math.min(y.length,p))}return y}_createExceedsLimitQueryResponse(t){let e=!1,i=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY,n=Number.POSITIVE_INFINITY;for(const r of t.outStatistics)if(r.statisticType==="exceedslimit"){i=r.maxPointCount!=null?r.maxPointCount:Number.POSITIVE_INFINITY,a=r.maxRecordCount!=null?r.maxRecordCount:Number.POSITIVE_INFINITY,n=r.maxVertexCount!=null?r.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")e=this.items.length>i;else if(this.items.length>a)e=!0;else{const r=ge(this.hasZ,this.hasM),o=this.featureAdapter;e=this.items.reduce((l,c)=>{const u=o.getGeometry(c);return l+(G(u)&&u.coords.length||0)},0)/r>n}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(e)}}]}}async _createStatisticsQueryResponse(t){const e={attributes:{}},i=[],a=new Map,n=new Map,r=new Map,o=new Map,l=new O(t,this.featureAdapter,this.fieldsIndex),c=t.outStatistics,{groupByFieldsForStatistics:u,having:h,orderByFields:f}=t,d=u&&u.length,m=!!d,x=m&&u[0],_=m&&!this.fieldsIndex.get(x);for(const I of c){const{outStatisticFieldName:V,statisticType:F}=I,p=I,g=F!=="exceedslimit"?I.onStatisticField:void 0,S=F==="percentile_disc"||F==="percentile_cont",v=F==="EnvelopeAggregate"||F==="CentroidAggregate"||F==="ConvexHullAggregate",z=m&&d===1&&(g===x||_)&&F==="count";if(m){if(!r.has(g)){const w=[];for(const E of u){const $=this._getAttributeValues(l,E,a);w.push($)}r.set(g,this._calculateUniqueValues(w,!v&&l.returnDistinctValues))}const T=r.get(g);for(const w in T){const{count:E,data:$,items:ie,itemPositions:De}=T[w],se=$.join(",");if(!h||l.validateItems(ie,h)){const M=o.get(se)||{attributes:{}};if(v){M.aggregateGeometries||(M.aggregateGeometries={});const{aggregateGeometries:R,outStatisticFieldName:N}=await this._getAggregateGeometry(p,ie);M.aggregateGeometries[N]=R}else{let R=null;if(z)R=E;else{const N=this._getAttributeValues(l,g,a),ae=De.map(Ee=>N[Ee]);R=S&&"statisticParameters"in p?this._getPercentileValue(p,ae):this._getStatisticValue(p,ae,null,l.returnDistinctValues)}M.attributes[V]=R}let $e=0;u.forEach((R,N)=>M.attributes[this.fieldsIndex.get(R)?R:"EXPR_"+ ++$e]=$[N]),o.set(se,M)}}}else if(v){e.aggregateGeometries||(e.aggregateGeometries={});const{aggregateGeometries:T,outStatisticFieldName:w}=await this._getAggregateGeometry(p,this.items);e.aggregateGeometries[w]=T}else{const T=this._getAttributeValues(l,g,a);e.attributes[V]=S&&"statisticParameters"in p?this._getPercentileValue(p,T):this._getStatisticValue(p,T,n,l.returnDistinctValues)}i.push({name:V,alias:V,type:"esriFieldTypeDouble"})}const y=m?Array.from(o.values()):[e];return this._sortFeatures(y,f,(I,V)=>I.attributes[V]),{fields:i,features:y}}async _getAggregateGeometry(t,e){const i=await Fe(()=>import("./geometryEngineJSON.3d6e7890.js"),["assets/geometryEngineJSON.3d6e7890.js","assets/geometryEngineBase.82b25ca5.js","assets/geometryEngineJSON.f9e9a36f.js","assets/json.879c9adc.js"]),{statisticType:a,outStatisticFieldName:n}=t,{featureAdapter:r,spatialReference:o,geometryType:l,hasZ:c,hasM:u}=this,h=e.map(m=>Q(l,c,u,r.getGeometry(m))),f=i.convexHull(o,h,!0)[0],d={aggregateGeometries:null,outStatisticFieldName:null};if(a==="EnvelopeAggregate"){const m=f?Ke(f):J(i.union(o,h));d.aggregateGeometries={...m,spatialReference:o},d.outStatisticFieldName=n||"extent"}else if(a==="CentroidAggregate"){const m=f?We(f):et(J(i.union(o,h)));d.aggregateGeometries={x:m[0],y:m[1],spatialReference:o},d.outStatisticFieldName=n||"centroid"}else a==="ConvexHullAggregate"&&(d.aggregateGeometries=f,d.outStatisticFieldName=n||"convexHull");return d}_getStatisticValue(t,e,i,a){const{onStatisticField:n,statisticType:r}=t;let o=null;return o=i!=null&&i.has(n)?i.get(n):oe(this.fieldsIndex.get(n))?ue({values:e,returnDistinct:a}):ce({values:e,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(n,o),o[r==="var"?"variance":r]}_getPercentileValue(t,e){const{onStatisticField:i,statisticParameters:a,statisticType:n}=t,{value:r,orderBy:o}=a,l=this.fieldsIndex.get(i);return dt(e,{value:r,orderBy:o,fieldType:l==null?void 0:l.type,isDiscrete:n==="percentile_disc"})}_getAttributeValues(t,e,i){if(i.has(e))return i.get(e);const a=this.fieldsIndex.get(e),n=this.items.map(r=>t.getFieldValue(r,e,a));return i.set(e,n),n}_getAttributeDataValues(t,e){return this.items.map(i=>t.getDataValue(i,{field:e.field,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal}))}async _getAttributeExpressionValues(t,e,i){const{arcadeUtils:a}=await tt(),n=a.createFunction(e),r=i&&a.getViewInfo(i);return t.getExpressionValues(this.items,n,r,a)}_calculateUniqueValues(t,e){const i={},a=this.items,n=a.length;for(let r=0;r<n;r++){const o=a[r],l=[];for(const u of t)l.push(u[r]);const c=l.join(",");e?i[c]==null&&(i[c]={count:1,data:l,items:[o],itemPositions:[r]}):i[c]==null?i[c]={count:1,data:l,items:[o],itemPositions:[r]}:(i[c].count++,i[c].items.push(o),i[c].itemPositions.push(r))}return i}async _getDataValues(t){const e=new O(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:i,field:a,normalizationField:n,normalizationType:r,normalizationTotal:o,scale:l}=t,c=i?{viewingMode:"map",scale:l,spatialReference:this.query.outSR||this.spatialReference}:null;return i?this._getAttributeExpressionValues(e,i,c):this._getAttributeDataValues(e,{field:a,field2:t.field2,field3:t.field3,fieldDelimiter:t.fieldDelimiter,normalizationField:n,normalizationType:r,normalizationTotal:o})}}function vt(s,t,e,i){const a=i.x-e.x,n=i.y-e.y,r=a*a+n*n,o=(t.x-e.x)*a+(t.y-e.y)*n,l=Math.min(1,Math.max(0,o/r));s.x=e.x+a*l,s.y=e.y+n*l}function ge(s,t){return s?t?4:3:t?3:2}var j;(function(s){s[s.NONE=0]="NONE",s[s.EDGE=1]="EDGE",s[s.VERTEX=2]="VERTEX"})(j||(j={}));class pe{constructor(t,e){this.coords=t,this.coordsIndex=e}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}export{Nt as A,U as E,de as F,Ft as J,At as M,$t as a,Et as b,te as c,Te as f,Z as g,C as l,Dt as o,j as q,Q as v,Mt as z};
