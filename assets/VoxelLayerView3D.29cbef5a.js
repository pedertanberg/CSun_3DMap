import{b as v,s as h,bv as W,aZ as g,r as t,G as o,h as f,z as x,ak as _,e as b,f as V,k as S}from"./index.f489a479.js";import{n as T}from"./LayerView3D.af0dc625.js";import{u as E}from"./LayerView.0083e383.js";var i;(function(e){e[e.API=1]="API",e[e.VerboseAPI=2]="VerboseAPI",e[e.Error=3]="Error"})(i||(i={}));let m=class extends T(E){constructor(){super(...arguments),this._usedMemory=0,this._futureMemory=0,this.type="voxel-3d",this._wasmLayerId=-1,this._handles=new v,this._dbgFlags=new Set}get baseUrl(){var e,s;return(s=(e=this.layer.parsedUrl)==null?void 0:e.path)!=null?s:""}get wasmLayerId(){return this._wasmLayerId}initialize(){var d;if(this._dbgFlags.add(i.Error),this.view.viewingMode!=="local")throw new h("voxel:unsupported-viewingMode","Voxel layers support local viewingMode only.",{});if(this.view._stage.renderView.renderingContext.type!==W.WEBGL2)throw new h("voxel:unsupported-context","Voxel layers are supported in WebGL2 rendering contexts only.",{});if(!((d=this.view._stage.renderView.renderingContext.capabilities.colorBufferFloat)!=null&&d.textureFloat))throw new h("voxel:missing-color-buffer-float","Voxel layers require the WebGL2 extension EXT_color_buffer_float",{});const e=this.layer.spatialReference;if(!g(e,this.view.spatialReference))throw new h("layerview:spatial-reference-incompatible","The spatial reference of this scene layer is incompatible with the spatial reference of the view",{});const s=this.layer.currentVariableId,a=this.layer.getVolume(s),l=this.layer.getVariable(s);if(t(a)&&t(l)){const n=a.dimensions[0],r=a.dimensions[1],u=a.zDimension;if(u>1){const p=a.dimensions[u],w=n.size*r.size*p.size;let y=1;switch(l.renderingFormat.type){case"Int16":case"UInt16":y=2;break;case"Int32":case"UInt32":case"Float32":y=4}this._futureMemory=y*w}}const c=this.view.addVoxelLayerViewToWasm(this).then(n=>{this._wasmLayerId=n,this._suspendedHandle=o(()=>this.suspended,r=>{const u=this.view.voxelWasm;t(u)&&u.setEnabled(this,!r)},f),this._handles.add([o(()=>this.layer.renderMode,r=>this._pushRenderModeToWasm(r)),o(()=>this.layer.currentVariableId,r=>this._pushCurrentVariableIdToWasm(r)),o(()=>this.layer.getSections(),r=>this._pushSectionsToWasm(r)),o(()=>this.layer.getVariableStyles(),r=>this._pushVariableStylesToWasm(r)),o(()=>this.layer.getVolumeStyles(),r=>this._pushVolumeStylesToWasm(r)),o(()=>this.layer.enableDynamicSections,r=>this._pushEnableDynamicSectionsToWasm(r)),o(()=>this.layer.enableIsosurfaces,r=>this._pushEnableIsosurfacesToWasm(r)),o(()=>this.layer.enableSections,r=>this._pushEnableSectionsToWasm(r)),o(()=>this.layer.enableSlices,r=>this._pushEnableSlicesToWasm(r))])}).catch(n=>{if(this.view.removeVoxelLayerViewFromWasm(this),this._wasmLayerId=-1,n===-1)throw new h("voxel:addLayer-failure","The voxel layer description was invalid.",{});if(n===-2)throw new h("voxel:addLayer-failure","The voxel layer web assembly module failed to download.",{})});this.addResolvingPromise(c)}destroy(){this.view.removeVoxelLayerViewFromWasm(this),this._suspendedHandle&&(this._suspendedHandle.remove(),this._suspendedHandle=null),this._handles=x(this._handles)}isUpdating(){const e=this.view.voxelWasm;return!(this._wasmLayerId<0||!t(e))&&e.isUpdating(this._wasmLayerId)}updatingFlagChanged(){this.notifyChange("updating")}getUsedMemory(){return this._usedMemory}getUnloadedMemory(){return this._futureMemory}ignoresMemoryFactor(){return!0}get performanceInfo(){return{nodes:0,displayedNumberOfFeatures:0,maximumNumberOfFeatures:0,totalNumberOfFeatures:0,core:null}}setUsedMemory(e){this._usedMemory=e,this._futureMemory=0}captureFrustum(){const e=this.view.voxelWasm;t(e)&&e.captureFrustum()}toggleFullVolumeExtentDraw(){const e=this.view.voxelWasm;t(e)&&e.toggleFullVolumeExtentDraw(this)}getLayerTimes(){let e=[];const s=this.view.voxelWasm;return t(s)&&(e=s.getLayerTimes(this)),e}getCurrentLayerTimeIndex(){let e=0;const s=this.view.voxelWasm;return t(s)&&(e=s.getCurrentLayerTimeIndex(this)),e}_pushRenderModeToWasm(e){const s=this.view.voxelWasm;this._dbg(i.VerboseAPI,"VoxelLayerView3D._pushRenderModeToWasm() called, "+(t(s)?"have WASM":"don't have WASM!!!")),!!t(s)&&s.setRenderMode(this,e)||this._dbg(i.Error,"VoxelLayerView3D._pushRenderModeToWasm() failed!")}_pushSectionsToWasm(e){const s=this.view.voxelWasm;this._dbg(i.VerboseAPI,"VoxelLayerView3D._pushSectionsToWasm() called, "+(t(s)?"have WASM":"don't have WASM!!!")),!!t(s)&&s.setStaticSections(this,e)||this._dbg(i.Error,"VoxelLayerView3D._pushSectionsToWasm() failed!")}_pushCurrentVariableIdToWasm(e){const s=this.view.voxelWasm;this._dbg(i.VerboseAPI,"VoxelLayerView3D._pushCurrentVariableIdToWasm() called!, "+(t(s)?"have WASM":"don't have WASM!!!")),!!t(s)&&s.setCurrentVariable(this,e)||this._dbg(i.Error,"VoxelLayerView3D._pushCurrentVariableIdToWasm() failed!")}_pushVariableStylesToWasm(e){const s=this.view.voxelWasm;this._dbg(i.VerboseAPI,"VoxelLayerView3D._pushVariableStylesToWasm() called, "+(t(s)?"have WASM":"don't have WASM!!!"));let a=!1;t(s)&&(a=s.setVariableStyles(this,e),a||this._dbg(i.Error,"VoxelLayerView3D._pushVariableStylesToWasm() failed!"))}_accountForEnableSlices(e,s){const a=t(s)?s:this.layer.enableSlices;for(let l=0;l<e.length;++l){const c=e[l];for(const d of c.slices)d.enabled=d.enabled&&a}}_pushVolumeStylesToWasm(e){const s=this.view.voxelWasm;this._dbg(i.VerboseAPI,"VoxelLayerView3D._pushVolumeStylesToWasm() called, "+(t(s)?"have WASM":"don't have WASM!!!"));let a=!1;t(s)&&(this._accountForEnableSlices(e,null),a=s.setVolumeStyles(this,e),a||this._dbg(i.Error,"VoxelLayerView3D._pushVolumeStylesToWasm() failed!"))}_pushEnableDynamicSectionsToWasm(e){const s=this.view.voxelWasm;this._dbg(i.VerboseAPI,"VoxelLayerView3D._pushEnableDynamicSectionsToWasm() called, "+(t(s)?"have WASM":"don't have WASM!!!"));let a=!1;t(s)&&(a=s.setEnableDynamicSections(this,e),a||this._dbg(i.Error,"VoxelLayerView3D._pushEnableDynamicSectionsToWasm() failed!"))}_pushEnableSlicesToWasm(e){const s=this.view.voxelWasm;this._dbg(i.VerboseAPI,"VoxelLayerView3D._pushEnableSlicesToWasm() called, "+(t(s)?"have WASM":"don't have WASM!!!"));let a=!1;if(t(s)){const l=this.layer.getVolumeStyles();this._accountForEnableSlices(l,e),a=s.setVolumeStyles(this,l),a||this._dbg(i.Error,"VoxelLayerView3D._pushEnableSlicesToWasm() failed!")}}_pushEnableIsosurfacesToWasm(e){const s=this.view.voxelWasm;this._dbg(i.VerboseAPI,"VoxelLayerView3D._pushEnableIsosurfacesToWasm() called, "+(t(s)?"have WASM":"don't have WASM!!!"));let a=!1;t(s)&&(a=s.setEnableIsosurfaces(this,e),a||this._dbg(i.Error,"VoxelLayerView3D._pushEnableIsosurfacesToWasm() failed!"))}_pushEnableSectionsToWasm(e){const s=this.view.voxelWasm;this._dbg(i.VerboseAPI,"VoxelLayerView3D._pushEnableSectionsToWasm() called, "+(t(s)?"have WASM":"don't have WASM!!!"));let a=!1;t(s)&&(a=s.setEnableSections(this,e),a||this._dbg(i.Error,"VoxelLayerView3D._pushEnableSectionsToWasm() failed!"))}_dbg(e,s){this._dbgFlags.has(e)&&(e===i.Error?_.getLogger(this.declaredClass).error(s):_.getLogger(this.declaredClass).warn(s))}};b([V()],m.prototype,"layer",void 0),b([V()],m.prototype,"baseUrl",null),m=b([S("esri.views.3d.layers.VoxelLayerView3D")],m);const A=m;export{A as default};
